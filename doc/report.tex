\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{color}
\usepackage{url}
\usepackage{array}
\usepackage{minted}
\usepackage{pifont}
\setlength{\skip\footins}{2cm}

\newminted{cpp}{linenos,frame=lines, xleftmargin=1cm,fontfamily=helvetica}
\newminted{ocaml}{linenos,frame=lines, xleftmargin=1cm,fontfamily=helvetica}
\newminted{java}{linenos,frame=lines, xleftmargin=1cm,fontfamily=helvetica}
\newminted{ruby}{linenos,frame=lines, xleftmargin=1cm,fontfamily=helvetica}
\newminted{cl}{linenos,frame=lines, xleftmargin=1cm,fontfamily=helvetica}
\newminted{ada}{frame=lines, xleftmargin=1cm,fontfamily=helvetica}

%\renewcommand\listingscaption{Code}
%%%%%%%%%%%%%
%\begin{listing}[H]
%\caption{Factorial in Ruby.}
%\label{code:ruby_fact}

%\end{listing}
%%%%%%%%%%%%%
\usemintedstyle{trac}

\newcommand{\cpp}{%
\textsc{C++}%
}
\title{Which Programming Language Is The Best?}
\author{
Matthieu \textsc{Dubet} \\
\emph{MSc Computer Science}
}

\begin{document}
\maketitle
\clearpage
\tableofcontents
\clearpage
\section{Introduction}
The term \emph{programming language} sometimes called \emph{computer language} doesn't have a strict definition. The most accurate one would be \emph{"A programming language is a language designed to express the possible computations made by a specified machine"}.\cite{wiki:definition} Alan Turing, one of the early computer scientists, described the list of all the computations doable by a standard processor ; and consequently, the programming languages which are able to express all these computations are called \emph{Turing-complete programming language}. For purpose of this presentation, we will limit our study to the latter (this excludes \emph{de facto} markup languages (\textsc{HTML},\textsc{XML} \ldots) and many domain-specific languages such as \textsc{SQL}).

\paragraph{}

So, if all those languages express the same computations, some questions arise :
\begin{itemize}
\item
Why are they plenty of programming languages all around the world ?
\item
Why are we still searching and creating new programming languages ?
\item
Are they \emph{better} languages than other ? What defines a \emph{good} language ?
\end{itemize}

To answer to these questions, we should start with an analogy which could help non-technical readers: both programming and natural languages are numerous, but like programming languages, most natural languages are designed to express the same set of \emph{humanation}\footnote{Fictional portmanteau word from human and computation}, which includes feeling,actions,ideas,facts\ldots

Despite this, there is an incredibly large set of natural languages out there, and for each one, its own syntax, its own semantic, its own popularity, its own roots, and finally its own value as a natural language.

It's the same for programming languages. Even if the goal is the same, the way to reach it may differ, and some languages may provide an easier, or quicker way, to complete each calculation. Even in the same language, there are different methods to reach the same point. Below is an illustration of those differences : first, a recursive factorial calculation implemented in \textsc{LISP}, next the same recursive factorial in \cpp and finally an iterative version in \cpp.


This shows the difference in syntax, but also in the way we \emph{think} about the algorithm. Between the first two codes, the most obvious difference is the type declaration in the second one ({\tt int n} instead of just {\tt n}), and between the last two, the algorithm is completely different in terms of how the machine computes this (\emph{recursive} vs \emph{iterative}).

%%%%%%%
\begin{clcode}
(defun factorial (n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
\end{clcode}
%%%%%%%
%%%%%%%
\begin{cppcode}
int recursive_factorial (int n) {
	if (n == 0) {
		return 1 ;
	} else {
		return (n * recursive_factorial(n-1) ) ;
	}
}
\end{cppcode}
%%%%%%%
%%%%%%%
\begin{cppcode}
int iterative_factorial(int n) {
	int result = 1 ;
	if (n <= 1) { return result ; }
	while ( n > 1 ) {
		result = result * n ;
		n = n - 1 ;
	}
	return result ;
}
\end{cppcode}
%%%%%%%
\pagebreak

\section{History}
\subsection{Early computing}
Again, it's difficult to define the "first programming language", due to the fact that the definition is somewhat cumbersome. 

Nevertheless, the first programming languages were created specifically for a machine, as such known as \emph{assembly language}.  The first one may have been the \textsc{ENIAC coding system}, designed to express ENIAC machine possible computations. The first language formally designed, but not implemented back then, would be \textsc{Plankalk\"ul} by Konrad Zuse in 1948.\cite{wiki:plankalkul}

At the end of the fifties appeared the first high-level languages, so-called because they're not tied to a particular computer model (they are one level higher than assembly languages). Thanks to this aspect, some of them are still in use\footnote{Maybe not exactly in the same form that 50's, but some kind of dialect} more than half a century later ! The main competitors in this ``oldest and still used''' race are :\begin{itemize}
\item
\textsc{FORTRAN}, which stands for Formula Translator, mainly used in the mathematical community. 
\item
\textsc{LISP}, for List Processor, with a fully parenthesized syntax inherited from lambda calculus, garbage collector, dynamic typing and some reflexivity.
\item
\textsc{COBOL}, for a weird and useless acronym, present in old financial companies.
\end{itemize}

\subsection{Twenty years of innovation}
The sixties introduced not only a breakthrough in the musical field (The Beatles in 1963, Led Zeppelin in 1968), but also in programming language research. Hence, the path opened by the previous generation lead to many deep improvements in terms of the \emph{style} of programming (not in terms of how we write, but in terms of how we think), which has been described as a \emph{programming paradigm}.
\begin{itemize}
\item
Even if the tendency was to create higher languages, some part of computer science (especially operating system vendors) still needed to write low level code, such as assembly. This was the problem that Bell Labs researcher Dennis Ritchie faced with the development of the \textsc{UNIX Operating System}. As a result, they decided to implement a \emph{system programming language}, featuring very fast performance without being tied to a specific computer architecture : the \textsc{C Programming Language} which has been quite a success.\footnote{TIOBE Index ranks it as the second most used language currently}
\item
The research for expressiveness and clarity led Nigaard and Dahl to a new kind of keyword in their \textsc{Simula} (1962) language : {\tt class}. The goal of this keyword was to increase the sustainability of large software codebase by creating full-featured type (containing there attributes, and their methods). Since then, the so-called \emph{object oriented programming}(OOP) paradigm is by far the most currently used in programming.
\item
This new programming paradigm has been so revolutionary that, some years later, in 1972, a team lead by Alan Kay from Xerox PARC (Palo Alto Research Center) released the first \emph{fully oriented object programming language}. Contrary to Simula, where classes were only part of the type system (for example, the type integer was not a class but a primitive type), \textsc{Smalltalk} considers types as class, and reversibly classes as type. While it's considered as the \emph{perfect} representation of an oriented object programming language from a theorical and educational point of view, it suffers from some drawbacks for industrial or mainstream purposes, especially in terms of performance.
\item
\textsc{ML} (for Meta Language) was created by Robin Milner in 1973 largely inspired by LISP. As a result, it's a functional programming language, but contrary to its spiritual roots, it allows side effects like traditional imperative language, and is statically typed. With those aspects, it's the first attempt to merge at this time classic imperative world (assembly languages, C, Simula, Fortran ..) and the more formal functional languages (which are closer to the mathematical definition of an algorithm).
\end{itemize}

\subsection{Thirty years of consolidation}
Since the end of the seventies, many programming languages were born, raised, and eventually died. 
The vast majority of today's code is done with language which has appeared after 1980. In fact, Java (1995), C++ (1983), PHP (1994), C\# (2001) constitutes almost 60\% of actual codebase.

Based on these facts, we may think that these languages introduced innovative ways to program, and hence have been widely adopted. There is no such thing! All those languages are more the result of previous generation consolidation and maturation, taking the best from each one to satisfy multiple goals.

During the 70's and the 80's, software became more and more complex, consequently, the programming language industry tried to respond to those new problems with various approaches :
\begin{itemize}
\item
Introduction of modularity to separate a codebase in different smaller parts to create reusable components, reducing development time thus cost. \textsc{Modula} (1977) and \textsc{Ada} (contracted by US Department of Defense in 1983) are considered the first modularized languages.

\item
Emphasis was put on creating accurate programs, to avoid highly cost by debugging and complex maintainability. This approach required new programming languages, \emph{stricter} in terms of possibilities than \emph{system programming languages}. Most of them are based on functional programming --- Ericsson's \textsc{Erlang} (1986), \textsc{Haskell} (1990), \textsc{OCaml} (1996) --- with the exception of \textsc{Eiffel} (1985), which is an object oriented language that introduced a new feature named \emph{Contract programming} for the verification of some properties (known as pre and post-conditions).
\item
Another approach which has been taken by the industry is the introduction of the vaguely defined \emph{scripting language}. It's a group of languages which are fairly young --- \textsc{Python} (1991), \textsc{Ruby} (1995), \textsc{PHP} (1995)\ldots --- and provide a simple and fast syntax, a dynamic typing and no compilation time. They are used for non critical performance part of a large codebase, such as plugins. Sometimes they are used during the conception phase as a \emph{prototyping language} (kind of a draft). Next is an example of a one-liner recursive factorial in Ruby.
\begin{rubycode}
def factorial (n)
  if n <= 1 then 1 else n * factorial(n-1) end
end
\end{rubycode}
\end{itemize}

\section{Characteristics of today most used languages}
 
We just saw that there was little fundamental innovation during the last thirty years but as we said, a big part of the actual codebase is made of languages I haven't mention yet.

I call them \emph{multi-paradigm enterprise programming language}, and there main members are \textsc{Java} (created by Sun Microsystems), \textsc{C\#} (Microsoft), \textsc{Objective-C} (Apple) and by some aspects \cpp (from AT\&T Bells Labs) et \textsc{Python} (sponsored by Google).

\paragraph{}
Those languages tried to respond to the vast majority of programmer's actual needs, consequently they have many similarities in their approach of software engineering:
\begin{itemize}
\item
Object-oriented base and modularity. All these languages implement the concepts of class and object, and the concept of \emph{packages} which regroup classes into one group to provide consistent reusable functionality.
\item
Large framework. They all provide a huge number of preprogrammed classes to access database, create graphical interface, perform network programming and so on\ldots
\item
Statically typed and compilation time error checking (with the exception of Python). To prevent some type errors, they all need the programmer to explicitly choose the type of a variable ; and they use compilation time to check many classical programming errors, instead of running time.
\item
Constant evolution and standardization. Those languages aren't fixed, they evolve to respond to new problematics faced by software developers. For example, the \textsf{C++11} standard (adopted in 2011) introduced multithreading programming facilities, to follow the emergence of multicore processor in mainstream computers. 
\item
Free, as in free beer and as in free speech.
\end{itemize}

\section{What should software developers expect from a modern programming language?}

Currently, software engineering is a huge market which suffers from the liberalism rules to create more and more complex software, faster and with less manpower. The choice of a programming language is an essential part of software conception : it should help the programmer deal with the constraints of the software, and provide by essence features to facilitate programmer's work. 
We could describe an hypothetical \emph{ideal} programming language with those characteristics :
\begin{itemize}
\item
Enforce good programming practice.
\begin{itemize}
\item
Clarity : the code should be explicit rather than implicit, the language shouldn't allow weird construct. In C, it's difficult to know the result of {\tt int n = 1 + (++2) + (3++) ;}.
\item
Expressiveness : the code should be able to say a lot of stuff in a minimum size. (For example, a three line Ruby code to list all files in a directory.)
\begin{rubycode}
File("/home/").each do |file|
	puts file
end
\end{rubycode}
\item
Sustainability is a consequence of clarity in long-terms
\end{itemize}
\item
Help catch bugs early in the development process. 
This include strong typing (don't allow a float to be invisibly converted to an int, or a string to an int), constant correctness (an attribute explicitly declared as constant shouldn't be modified), pattern matching completeness (\textsc{OCaml} example below), and many more possible error preventing.
\begin{ocamlcode}
type t_integer =
   T_Zero
  | T_Succ of int
  | T_Forgot_Constructor_So_The_Compiler_Warned_Us

let x = T_Succ(6) in (
match x with
   T_Zero -> 0
  | T_Succ(x) -> (x+1)
)
(*
File "match.ml", line 7, characters 21-75:
 Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
	 T_Forgot_Constructor_So_The_Compiler_Warned_Us
*)
\end{ocamlcode}

\item
Provide many pre-coded components, to avoid \emph{reinventing the wheel}.
For example, a simple program which shows a window with an ``Hello World'' message. This would have taken many more lines (thus time) to develop in assembly or C for example, because we can now reuse many elements already provided by the \textsc{Java Library} (such as JButton, JFrame and JLabel).
\begin{javacode}
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
 
public class SwingExample {
    public static void main(String[] args) {
            public void run() {
                JFrame f = new JFrame("Swing Example Window");
                // Set a simple Layout Manager that arranges the contained
                // Components
                f.setLayout(new FlowLayout());
                 // Add some Components
                f.add(new JLabel("Hello, world!"));
                f.add(new JButton("Press me!"));
                // "Pack" the window, making it "just big enough".
                f.pack();
                // Set the visibility as true, thereby displaying it
                f.setVisible(true);
            }
        });
    }
}
\end{javacode}

\item
High performance. It depends on the software, but sometimes one needs a high performance programming language (for example, the same program in Ruby takes about twenty times longer to run than in C). A need which is especially true in video games industry, operating system vendors, embedded systems (in cars, planes\ldots), sectors which can't afford low performance programming languages.
\item
Flexibility. A more controversial point, which may be opposed to the first one. It's the motto of the \cpp\cite{stroustrup}, and one of its main criticism\footnote{But as Bjarne Stroustrup (creator of C++) said in : ``The major cause of complaints is C++['s] undoubted success. As someone remarked: There are only two kinds of programming languages: those people always bitch about and those nobody uses.''}
, it allows mixing different and opposed programming styles, hence provide a great flexibility and thus can be used in almost all the field of computer science, but has a higher entry level and can lead to obscure codebase if the programmer doesn't code well.
\end{itemize}

\section{Conclusion}
Of course, there is no such thing as the \emph{best programming language}.

\paragraph{}

 During our little travel into Computer Science history,  we clearly remarks that after the prolific 50's and 60's, innovation slows down and new programming languages tend to merge different characteristics into one to create multi purpose languages rather than introduced new programming paradigm.

The iconic multi-paradigm language may be \cpp, which has evolved from some additions to the \textsc{C} to one of the most complete and successful language in history. Can we describe it has the best language out there ? Surely no. Someone will argue it has an heavy syntax compared to Ruby, another that it allows mixing multiple paradigm ending in a lot of errors (contrary to Java which force object oriented programming), the next one that it lacks purely functional programming compared to Haskell, and so on\ldots

\paragraph{}

In conclusion, we could say that for each specific task, there is a most adapted programming language, and maybe, in the future, one to rule them all ?
\newpage
\bibliographystyle{plain}
\bibliography{bib}
\end{document}
